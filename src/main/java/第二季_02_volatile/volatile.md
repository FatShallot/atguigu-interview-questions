> 视频P2到P9
# volatile
是一种JVM提供的轻量级的同步机制  
三大特性：  
- 保证可见性
- 不保证原子性
- 禁止指令重排

# JMM（Java内存模型）
是一组规则或规范，定义了程序中各个变量的访问方式
## JMM关于同步的规定
- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
## 主内存与工作内存
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（或者叫栈空间），工作内存时每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。  
## 三大特性
- 可见性
- 原子性
- 有序性
# 可见性还有一个问题（怎么办呢?视频没说）
有可能存在一种情况，线程T1修改了共享变量X的值，但还没更新到主内存，此时线程T2也修改了X的值，此时T1的工作内存中的共享变量的值对T2是不可见的，这种工作内存与主内存同步延迟现象会造成可见性问题  

# 可见性
# 原子性
完整性，不可分割  
某个线程在做某个业务时不可以被加塞或者分割，需要完整，要么同时成功，要么同时失败  

# i++
在多线程环境下是不安全的，因为它不是原子操作
其实是i=i+1，一共是3步操作，4个字节码指令
```
getfield    #获取值
iadd    #在工作内存里加1
putfield    #把操作后的值写回主内存
```

# 怎么解决原子性问题
- 给方法加synchronized关键字
- 使用原子类

# 指令重排
计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分一下三种  
源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令  
进行指令重排的条件：  
- 在单线程环境里面会确保程序最终执行结果和代码顺序执行的结果一致
- 处理器在进行重排序时必须要考虑指令之间的数据依赖性
- 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

就是说，由于指令重排，代码的执行顺序跟你写的顺序不一定是一样的，会导致错误  
加了volatile会禁止指令重排  
## volatile会禁止指令重排
内存屏障 memory barrier 又叫内存栅栏  
由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条memory barrier，就会告诉编译器和CPU，不管什么指令都不能和这条memory barrier指令重排序，也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另外一个作用就是强制刷出个各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些线程的最新版本。  

# 总结
## 工作内存与主内存同步延迟现象导致的可见性问题
可以使用synchronized或volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见
## 对于指令重排导致的可见性问题和有序性问题
用volatile关键字解决