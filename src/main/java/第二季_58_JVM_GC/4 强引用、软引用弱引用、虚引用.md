> 视频P72到P80

# 强引用

当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM，也不会对该对象进行回收，死都不回收

强引用是最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还活着，垃圾回收器就不会回收这个对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是强引用。当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收的，即使该对象以后永远都不会被用到，JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因

对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应强引用赋值为null，一般认为就是可以被垃圾回收的（具体回收时机要看垃圾收集策略）

# 软引用

需要java.lang.reg.SoftReference类来实现，对于软引用的对象来说，当系统内存充足时不会被回收，当系统内存不足时会被回收。软引用通常用在对内存敏感的程序中，比如高速缓存

# 弱引用

需要java.lang.reg.WeakReference类来实现，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存

# 软引用和弱引用的使用场景

图片缓存，键是图片路径，值是图片对象的软引用

```java
Map<String, SoftReference<Bitmap>>
```

# WeakHashMap类

如果主键被置为null，只要gc，就会回收map里这条entry（即主键为空）的内容

# 虚引用

需要java.lang.reg.PhantomReference类来实现。虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和**引用队列（ReferenceQueue）**联合使用。

虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finilize以后，做某些事情的机制。PhathomRegerence的get方法总是返回null，因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。

设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。Java允许使用finilize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

